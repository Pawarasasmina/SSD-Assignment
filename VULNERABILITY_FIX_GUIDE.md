# Security Vulnerability Fix Guide

This document provides step-by-step instructions on how to fix each of the 7 identified vulnerabilities in the Healthcare Management System, aligned with the OWASP Top 10 2021 categories.

## 1. Hardcoded Database Credentials (A07:2021 – Identification and Authentication Failures)

### Problem
Database credentials are hardcoded in `db.js`, exposing sensitive connection information.

### Fix Steps

1. **Install dotenv if not already installed**
```bash
cd backend
npm install dotenv --save
```

2. **Create or update .env file in the backend directory**
```
MONGO_URI=mongodb+srv://username:password@cluster0.y694y.mongodb.net/?retryWrites=true&w=majority&appName=Cluster0
```

3. **Update db.js file**

Original code:
```javascript
const mongoose = require("mongoose");

mongoose.set("strictQuery", true, "userNewUrlParser", true);

const connection = async () => {
  try {
    await mongoose.connect(
      "mongodb+srv://username:password@cluster0.y694y.mongodb.net/?retryWrites=true&w=majority&appName=Cluster0"
    );
    console.log("MongoDB Connected~");
  } catch (e) {
    console.error(e.message);
    process.exit();
  }
};

module.exports = connection;
```

Updated code:
```javascript
const mongoose = require("mongoose");
require("dotenv").config();

const dburl = process.env.MONGO_URI;

if (!dburl) {
  console.error("MONGO_URI is not defined in environment variables");
  process.exit(1);
}

mongoose.set("strictQuery", true, "userNewUrlParser", true);

const connection = async () => {
  try {
    await mongoose.connect(dburl);
    console.log("MongoDB Connected~");
  } catch (e) {
    console.error(e.message);
    process.exit();
  }
};

module.exports = connection;
```

## 2. Hardcoded JWT Secrets (A05:2021 – Security Misconfiguration)

### Problem
JWT secrets are hardcoded in the application code, which is a significant security risk.

### Fix Steps

1. **Ensure dotenv is installed**
```bash
cd backend
npm install dotenv --save
```

2. **Create or update .env file in the backend directory**
```
JWT_SECRET=your_secure_random_secret
```

3. **Generate a secure random secret**

Create a file `generateSecret.js` in the config directory:
```javascript
const crypto = require('crypto');

const secret = crypto.randomBytes(32).toString('hex');
console.log('Generated JWT Secret:', secret);
console.log('Add this to your .env file as JWT_SECRET');
```

Run it to generate a secure secret:
```bash
node config/generateSecret.js
```

4. **Update userRoutes.js to use environment variable**

Original code:
```javascript
const jwt = require('jsonwebtoken');
// JWT token creation with hardcoded secret
const token = jwt.sign({ id: user.id, email: user.email }, "your-secret-key", { expiresIn: "1h" });
```

Updated code:
```javascript
const jwt = require('jsonwebtoken');
require('dotenv').config();

// JWT Secret Key from environment variable
const JWT_SECRET = process.env.JWT_SECRET;
if (!JWT_SECRET) {
  console.error('JWT_SECRET is not defined in environment variables');
  process.exit(1);
}

// JWT token creation with environment variable
const token = jwt.sign({ id: user.id, email: user.email }, JWT_SECRET, { expiresIn: "1h" });
```

## 3. Missing Security Headers & CORS Misconfiguration (A05:2021 – Security Misconfiguration)

### Problem
The application lacks important security headers and has a permissive CORS policy which can expose it to various attacks.

### Fix Steps

1. **Install Helmet.js to add security headers**
```bash
cd backend
npm install helmet --save
```

2. **Update server.js to implement Helmet and proper CORS configuration**

Original code:
```javascript
const express = require("express");
const cors = require("cors");
const mongoose = require("mongoose");

const app = express();
const port = process.env.PORT || 3000;

// Basic CORS setup with no restrictions
app.use(cors());
```

Updated code:
```javascript
const express = require("express");
const cors = require("cors");
const mongoose = require("mongoose");
const helmet = require('helmet');
require("dotenv").config(); // Load environment variables

const app = express();
const port = process.env.PORT || 3000;

// Apply Helmet middleware to set security headers
app.use(helmet());

// Configure CORS with more restrictive settings
app.use(
  cors({
    origin: process.env.NODE_ENV === 'production' 
      ? 'https://your-production-domain.com' 
      : 'http://localhost:5173',
    methods: ["GET", "POST", "PUT", "DELETE"],
    allowedHeaders: ['Content-Type', 'Authorization'],
    credentials: true,
    maxAge: 86400, // Cache preflight requests for 1 day
  })
);
```

3. **Add Content-Security-Policy for stronger protection**

```javascript
// Add custom CSP header for more granular control
app.use((req, res, next) => {
  res.setHeader(
    'Content-Security-Policy',
    "default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline'; img-src 'self' data:; font-src 'self'; connect-src 'self'"
  );
  next();
});
```

## 4. Lack of Input Validation (A04:2021 – Insecure Design)

### Problem
Many routes don't properly validate or sanitize user input, making the application vulnerable to various attacks.

### Fix Steps

1. **Install validation libraries**
```bash
cd backend
npm install express-validator xss-clean --save
```

2. **Create a validation middleware file**

Create a file `middleware/validation.js`:
```javascript
const { body, param, validationResult } = require('express-validator');
const xss = require('xss-clean');

// Common validation middleware
const validateRequest = (req, res, next) => {
  const errors = validationResult(req);
  if (!errors.isEmpty()) {
    return res.status(400).json({ errors: errors.array() });
  }
  next();
};

// XSS prevention middleware
const preventXSS = xss();

// User registration validation
const validateUserRegistration = [
  body('name').trim().notEmpty().withMessage('Name is required')
    .isLength({ min: 2, max: 50 }).withMessage('Name must be between 2 and 50 characters'),
  body('email').trim().isEmail().withMessage('Please provide a valid email'),
  body('password').isLength({ min: 8 }).withMessage('Password must be at least 8 characters')
    .matches(/^(?=.*\d)(?=.*[a-z])(?=.*[A-Z])(?=.*[!@#$%^&*])/).withMessage('Password must contain at least one uppercase letter, one lowercase letter, one number, and one special character'),
  body('phone').optional().isMobilePhone().withMessage('Please provide a valid phone number'),
  validateRequest
];

// Product validation
const validateProduct = [
  body('name').trim().notEmpty().withMessage('Product name is required'),
  body('price').isNumeric().withMessage('Price must be a number'),
  body('description').trim().notEmpty().withMessage('Description is required'),
  body('category').trim().notEmpty().withMessage('Category is required'),
  validateRequest
];

module.exports = {
  validateUserRegistration,
  validateProduct,
  preventXSS
};
```

3. **Apply the validation in routes**

Update `userRoutes.js`:
```javascript
const express = require("express");
const router = express.Router();
const { validateUserRegistration, preventXSS } = require('../middleware/validation');
const User = require("../models/User");

// Apply XSS prevention to all routes
router.use(preventXSS);

// Register user with validation
router.post("/register", validateUserRegistration, async (req, res) => {
  // Rest of the code...
});
```

Update `productRoutes.js`:
```javascript
const express = require("express");
const router = express.Router();
const { validateProduct, preventXSS } = require('../middleware/validation');
const Product = require("../models/Product");

// Apply XSS prevention to all routes
router.use(preventXSS);

// Create product with validation
router.post("/", validateProduct, async (req, res) => {
  // Rest of the code...
});
```

## 5. Password Storage in Plain Text (A02:2021 – Cryptographic Failures)

### Problem
The application stores user passwords in plain text in the database, exposing user credentials if the database is compromised.

### Fix Steps

1. **Install bcrypt**
```bash
cd backend
npm install bcrypt --save
```

2. **Modify the User.js model**

Original code:
```javascript
const mongoose = require("mongoose");

const userSchema = new mongoose.Schema({
  id: { type: String, unique: true },
  name: { type: String, required: true },
  email: { type: String, required: true, unique: true },
  password: { type: String, required: true }, // Plain text password
  phone: { type: String },
  userLevel: { type: Number, default: 0 }, // 0: Customer, 1: Seller, 2: Admin
  shopId: { type: String, default: null },
});

module.exports = mongoose.model("users", userSchema);
```

Updated code:
```javascript
const mongoose = require("mongoose");
const bcrypt = require("bcrypt");

const userSchema = new mongoose.Schema({
  id: { type: String, unique: true },
  name: { type: String, required: true },
  email: { type: String, required: true, unique: true },
  password: { type: String, required: true }, // Will store hashed password
  phone: { type: String },
  userLevel: { type: Number, default: 0 }, // 0: Customer, 1: Seller, 2: Admin
  shopId: { type: String, default: null },
});

// Hash password before saving
userSchema.pre("save", async function (next) {
  if (!this.isModified("password")) return next();
  try {
    const salt = await bcrypt.genSalt(10);
    this.password = await bcrypt.hash(this.password, salt);
    next();
  } catch (error) {
    next(error);
  }
});

// Add method to compare password
userSchema.methods.comparePassword = async function (candidatePassword) {
  return await bcrypt.compare(candidatePassword, this.password);
};

module.exports = mongoose.model("users", userSchema);
```

3. **Update login route**

Update `userRoutes.js`:
```javascript
router.post("/login", async (req, res) => {
  const { email, password } = req.body;

  try {
    const user = await User.findOne({ email });
    if (!user) {
      return res.status(400).json({ message: "Invalid email or password" });
    }

    // Use the comparePassword method
    const isMatch = await user.comparePassword(password);
    if (!isMatch) {
      return res.status(400).json({ message: "Invalid email or password" });
    }

    // Rest of the login process...
  } catch (error) {
    console.error("Failed to login user:", error.message);
    res
      .status(400)
      .json({ message: "Failed to login user", error: error.message });
  }
});
```

## 6. NoSQL Injection (A03:2021 – Injection)

### Problem
The application uses MongoDB queries with unvalidated user input, making it susceptible to NoSQL injection attacks.

### Fix Steps

1. **Install express-validator if not already installed**
```bash
cd backend
npm install express-validator --save
```

2. **Implement validation in routes**

Update `cartproductRoutes.js`:
```javascript
const express = require("express");
const router = express.Router();
const { body, param, validationResult } = require('express-validator');
const cartProduct = require("../models/cartProduct");

router.get("/test", (req, res) => res.send("route is working"));

// Validation middleware
const validateCartProduct = [
  body('productId').notEmpty().isString(),
  body('userId').notEmpty().isString(),
  body('quantity').isInt({ min: 1 }),
  body('price').isNumeric()
];

// Add cart product with validation
router.post("/", validateCartProduct, (req, res) => {
  // Check for validation errors
  const errors = validationResult(req);
  if (!errors.isEmpty()) {
    return res.status(400).json({ errors: errors.array() });
  }
  
  cartProduct
    .create(req.body)
    .then(() => res.json({ msg: "Successfully added to the cart" }))
    .catch((error) => res.status(400).json({ msg: "Cart adding failed", error: error.message }))
});

// Get cart items by ID with validation
router.get("/:id", param('id').isMongoId(), (req, res) => {
  const errors = validationResult(req);
  if (!errors.isEmpty()) {
    return res.status(400).json({ errors: errors.array() });
  }
  
  cartProduct
    .findById(req.params.id)
    .then((cartProduct) => {
      if (!cartProduct) {
        return res.status(404).json({ msg: "Cart item not found" });
      }
      res.json(cartProduct);
    })
    .catch((error) => res.status(400).json({ msg: "CartItems getting by id failed", error: error.message }))
});
```

3. **Use mongoose's built-in validation and sanitization**

Example for `productRoutes.js`:
```javascript
// Get products by ID with validation
router.get("/:id", param('id').isMongoId(), (req, res) => {
  const errors = validationResult(req);
  if (!errors.isEmpty()) {
    return res.status(400).json({ errors: errors.array() });
  }

  Product.findById(req.params.id)
    .then((product) => {
      if (!product) {
        return res.status(404).json({ msg: "Product not found" });
      }
      res.json(product);
    })
    .catch((error) => res.status(500).json({ error: error.message }));
});
```

## 7. Insecure File Upload Configuration (A01:2021 – Broken Access Control)

### Problem
The file upload configuration doesn't validate file types or restrict file sizes, which could lead to malicious file uploads.

### Fix Steps

1. **Update multerConfig.js**

Original code:
```javascript
const multer = require("multer");
const path = require("path");

// Set up multer for file uploads
const storage = multer.diskStorage({
  destination: function (req, file, cb) {
    cb(null, "uploads/"); // Store files in 'uploads' directory
  },
  filename: function (req, file, cb) {
    cb(null, Date.now() + path.extname(file.originalname)); // Rename files
  },
});

const upload = multer({ storage: storage });

module.exports = upload;
```

Updated code:
```javascript
const multer = require("multer");
const path = require("path");
const fs = require("fs");

// Ensure the upload directory exists
const uploadDir = path.join(__dirname, "../uploads");
if (!fs.existsSync(uploadDir)) {
  fs.mkdirSync(uploadDir);
}

// Define allowed file types
const allowedFileTypes = ['image/jpeg', 'image/png', 'image/gif', 'application/pdf'];

// Set up multer for file uploads with enhanced security
const storage = multer.diskStorage({
  destination: function (req, file, cb) {
    cb(null, uploadDir); // Use the upload directory path
  },
  filename: function (req, file, cb) {
    // Create a safe filename to prevent path traversal attacks
    const sanitizedFilename = file.originalname.replace(/[^a-zA-Z0-9\-_.]/g, '_');
    cb(null, Date.now() + '-' + sanitizedFilename); // Create a unique filename
  },
});

// Create file filter
const fileFilter = (req, file, cb) => {
  if (allowedFileTypes.includes(file.mimetype)) {
    cb(null, true);
  } else {
    cb(new Error('Invalid file type. Only jpeg, png, gif and pdf are allowed.'), false);
  }
};

// Configure multer with limits and file filter
const upload = multer({ 
  storage: storage,
  limits: {
    fileSize: 5 * 1024 * 1024, // 5MB size limit
  },
  fileFilter: fileFilter
});

module.exports = upload;
```

2. **Apply the updated multer configuration in routes that handle file uploads**

Example update for a route that uses file uploads:
```javascript
const express = require('express');
const router = express.Router();
const upload = require('../config/multerConfig');
const Product = require('../models/Product');

// Upload product image with enhanced security
router.post('/upload/:id', upload.single('image'), async (req, res) => {
  try {
    if (!req.file) {
      return res.status(400).json({ message: 'No file uploaded or invalid file type' });
    }

    const product = await Product.findById(req.params.id);
    if (!product) {
      return res.status(404).json({ message: 'Product not found' });
    }

    // Update product with image path
    product.imageUrl = `/uploads/${req.file.filename}`;
    await product.save();

    res.json({ message: 'Image uploaded successfully', product });
  } catch (error) {
    res.status(500).json({ message: 'Error uploading file', error: error.message });
  }
});
```

3. **Handle file upload errors**

Add error handling middleware in `server.js`:
```javascript
// Multer error handling middleware
app.use((err, req, res, next) => {
  if (err instanceof multer.MulterError) {
    if (err.code === 'LIMIT_FILE_SIZE') {
      return res.status(400).json({ message: 'File too large. Maximum size is 5MB.' });
    }
    return res.status(400).json({ message: 'File upload error', error: err.message });
  }
  next(err);
});
```
